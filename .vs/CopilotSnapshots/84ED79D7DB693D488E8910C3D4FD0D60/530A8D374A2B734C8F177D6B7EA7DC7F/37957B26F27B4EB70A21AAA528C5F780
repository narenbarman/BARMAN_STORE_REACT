import React, { useState, useCallback, useEffect, useRef } from 'react';
import { Plus, Trash2 } from 'lucide-react';
import { customersApi, productsApi, billingApi, creditApi, usersApi } from '../services/api';
import './BillingTab.css';

const createEmptyItem = () => ({
  id: Date.now() + Math.random(),
  name: '',
  price: 0,
  qty: 1,
  unit: 'pcs',
  disc: 0,
  discType: 'fixed',
  amount: 0
});

const BillingSystem = () => {
  const [customer, setCustomer] = useState({ name: '', email: '', phone: '', address: '' });
  const [items, setItems] = useState([createEmptyItem()]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [paidAmount, setPaidAmount] = useState(0);
  const [lastShareText, setLastShareText] = useState('');
  const [lastShareNumber, setLastShareNumber] = useState('');

  const [customersList, setCustomersList] = useState([]);
  const [productsList, setProductsList] = useState([]);

  // Customer validation state
  const [customerValidation, setCustomerValidation] = useState({
    isValid: true,
    errors: [],
    warnings: [],
    hasValidation: false
  });

  const customerSearchTimeout = useRef(null);

  useEffect(() => {
    const fetchInitialData = async () => {
      setLoading(true);
      setError(null);

      try {
        const [customersData, productsData] = await Promise.all([
          customersApi.getAll(),
          productsApi.getAll()
        ]);
        setCustomersList(customersData || []);
        setProductsList(productsData || []);
      } catch (err) {
        console.error('Error fetching initial data:', err);
        setError('Failed to load data. Please refresh the page.');
      } finally {
        setLoading(false);
      }
    };

    fetchInitialData();
  }, []);

  useEffect(() => {
    return () => {
      if (customerSearchTimeout.current) {
        clearTimeout(customerSearchTimeout.current);
      }
    };
  }, []);

  // Validate customer info whenever customer data or customersList changes
  useEffect(() => {
    // Pass customer.id if it exists (for existing customers) to exclude self from duplicate check
    const validation = validateCustomerInfo(customer, customersList, customer.id || null);
    setCustomerValidation(validation);
  }, [customer, customersList]);

  const calculateAmount = useCallback((price, qty, disc, discType) => {
    const priceNum = Number(price) || 0;
    const qtyNum = Math.max(1, Number(qty) || 1);
    const discNum = Number(disc) || 0;

    const subtotal = priceNum * qtyNum;

    let discountAmount = 0;
    if (discType === 'percentage') {
      const validDiscPercent = Math.min(100, Math.max(0, discNum));
      discountAmount = (subtotal * validDiscPercent) / 100;
    } else {
      discountAmount = Math.min(subtotal, Math.max(0, discNum));
    }

    return { amount: Math.max(0, subtotal - discountAmount) };
  }, []);

  const handleProductChange = useCallback((index, field, value) => {
    setItems((prevItems) => {
      const newItems = [...prevItems];

      if (field === 'name') {
        const matchedProduct = productsList.find(
          (product) => product.name && product.name.toLowerCase() === value.trim().toLowerCase()
        );

        if (matchedProduct) {
          const price = Number(matchedProduct.price) || 0;
          const disc = Number(matchedProduct.defaultDiscount) || 0;
          const discType = matchedProduct.discountType || 'fixed';

          newItems[index] = {
            ...newItems[index],
            name: matchedProduct.name,
            productId: matchedProduct.id,
            price,
            qty: 1,
            unit: matchedProduct.uom || matchedProduct.unit || 'pcs',
            disc,
            discType,
            amount: calculateAmount(price, 1, disc, discType).amount
          };
        } else {
          newItems[index] = { ...newItems[index], name: value };
          newItems[index].amount = calculateAmount(
            newItems[index].price,
            newItems[index].qty,
            newItems[index].disc,
            newItems[index].discType
          ).amount;
        }
      } else if (field === 'price') {
        newItems[index].price = value;
        newItems[index].amount = calculateAmount(value, newItems[index].qty, newItems[index].disc, newItems[index].discType).amount;
      } else if (field === 'qty') {
        const qty = Math.max(1, Number(value) || 1);
        newItems[index].qty = qty;
        newItems[index].amount = calculateAmount(newItems[index].price, qty, newItems[index].disc, newItems[index].discType).amount;
      } else if (field === 'disc') {
        const disc = Number(value) || 0;
        newItems[index].disc = disc;
        newItems[index].amount = calculateAmount(newItems[index].price, newItems[index].qty, disc, newItems[index].discType).amount;
      } else if (field === 'discType') {
        newItems[index].discType = value;
        newItems[index].amount = calculateAmount(newItems[index].price, newItems[index].qty, newItems[index].disc, value).amount;
      } else {
        newItems[index][field] = value;
      }

      return newItems;
    });
  }, [calculateAmount, productsList]);

  const addItem = () => setItems((prev) => [...prev, createEmptyItem()]);

  const removeItem = (index) => {
    setItems((prev) => (prev.length > 1 ? prev.filter((_, i) => i !== index) : prev));
  };

  const totalBill = items.reduce((sum, item) => sum + item.amount, 0);
  const paidClamped = Math.max(0, Math.min(Number(paidAmount || 0), Number(totalBill || 0)));
  const creditAmount = Math.max(0, Number(totalBill) - paidClamped);
  const totalDiscount = items.reduce((sum, item) => {
    const priceNum = Number(item.price) || 0;
    const qtyNum = Math.max(1, Number(item.qty) || 1);
    const discNum = Number(item.disc) || 0;
    if (item.discType === 'percentage') {
      const validDiscPercent = Math.min(100, Math.max(0, discNum));
      return sum + (priceNum * qtyNum * validDiscPercent) / 100;
    }
    return sum + Math.min(priceNum * qtyNum, Math.max(0, discNum));
  }, 0);

  const refreshData = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const [customersData, productsData] = await Promise.all([
        customersApi.getAll(),
        productsApi.getAll()
      ]);
      setCustomersList(customersData || []);
      setProductsList(productsData || []);
    } catch (err) {
      console.error('Error refreshing data:', err);
      setError('Failed to refresh data. Please try again.');
    } finally {
      setLoading(false);
    }
  }, []);

  const formatCurrency = (value) => new Intl.NumberFormat('en-IN', {
    style: 'currency',
    currency: 'INR',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(value);

  const handleCustomerChange = useCallback((e) => {
    const { value } = e.target;

    if (customerSearchTimeout.current) {
      clearTimeout(customerSearchTimeout.current);
    }

    const exactMatch = customersList.find((c) => c.name && c.name.toLowerCase() === value.toLowerCase());
    if (exactMatch) {
      setCustomer({ ...exactMatch });
      return;
    }

    setCustomer((prev) => ({ ...prev, name: value }));

    if (value.length >= 2) {
      customerSearchTimeout.current = setTimeout(async () => {
        try {
          const searchResults = await customersApi.search(value);
          if (searchResults && searchResults.length > 0) {
            setCustomer({ ...searchResults[0] });
          }
        } catch (err) {
          console.error('Error searching customers:', err);
        }
      }, 300);
    }
  }, [customersList]);

  const handleCreateBill = async () => {
    const hasItems = items.some((it) => it.name && it.amount > 0);

    // Validate customer information
    const validation = validateCustomerInfo(customer, customersList);
    if (!validation.isValid) {
      const errorList = validation.errors.join('\n\n');
      alert(`❌ Cannot create bill - Customer information is invalid:\n\n${errorList}`);
      return;
    }

    if (!hasItems) {
      alert('Please add at least one item to the bill.');
      return;
    }

    const paid = paidClamped;
    const normalizePhone = (value) => String(value || '').replace(/\D/g, '');
    const isSame = (a, b) => String(a || '').trim().toLowerCase() === String(b || '').trim().toLowerCase();
    const findCustomerMatch = () => {
      const phone = normalizePhone(customer.phone);
      if (phone) {
        const match = customersList.find((c) => normalizePhone(c.phone) === phone);
        if (match) return match;
      }
      const name = String(customer.name || '').trim().toLowerCase();
      if (!name) return null;
      const email = String(customer.email || '').trim().toLowerCase();
      return customersList.find((c) => {
        if (email && String(c.email || '').trim().toLowerCase() === email) return true;
        return String(c.name || '').trim().toLowerCase() === name;
      }) || null;
    };

    const payload = {
      customer_id: customer.id || null,
      customer_name: customer.name,
      customer_email: customer.email || null,
      customer_phone: customer.phone || null,
      customer_address: customer.address || null,
      discount_amount: Number(totalDiscount.toFixed(2)),
      total_amount: Number(totalBill.toFixed(2)),
      paid_amount: Number(paid.toFixed(2)),
      credit_amount: Number(creditAmount.toFixed(2)),
      payment_method: 'cash',
      payment_status: paid < Number(totalBill || 0) ? 'pending' : 'paid',
      bill_type: 'sales',
      items: items
        .filter((it) => it.name && Number(it.amount) > 0)
        .map((it) => ({
          product_id: it.productId || null,
          product_name: it.name,
          mrp: Number(it.price) || 0,
          qty: Number(it.qty) || 0,
          unit: it.unit || 'pcs',
          discount:
            it.discType === 'percentage'
              ? (Number(it.price) || 0) * (Number(it.qty) || 0) * (Math.min(100, Math.max(0, Number(it.disc) || 0)) / 100)
              : Number(it.disc) || 0,
          amount: Number(it.amount) || 0
        }))
    };

    try {
      setIsSubmitting(true);

      // Ensure customer exists (create or update)
      let resolvedCustomerId = payload.customer_id;
      let customerRecord = resolvedCustomerId
        ? customersList.find((c) => c.id === resolvedCustomerId)
        : findCustomerMatch();

      if (customerRecord) {
        const needsUpdate =
          !isSame(customerRecord.name, payload.customer_name) ||
          !isSame(customerRecord.email, payload.customer_email) ||
          !isSame(normalizePhone(customerRecord.phone), normalizePhone(payload.customer_phone)) ||
          !isSame(customerRecord.address, payload.customer_address);
        if (needsUpdate) {
          await usersApi.update(customerRecord.id, {
            name: payload.customer_name,
            email: payload.customer_email,
            phone: payload.customer_phone,
            address: payload.customer_address,
            role: 'customer'
          });
        }
        resolvedCustomerId = customerRecord.id;
      } else {
        const created = await usersApi.create({
          name: payload.customer_name,
          email: payload.customer_email,
          phone: payload.customer_phone,
          address: payload.customer_address,
          role: 'customer'
        });
        resolvedCustomerId = created?.user?.id || null;
        if (created?.user) {
          setCustomersList((prev) => [...prev, created.user]);
        }
      }

      // Ensure products exist (create or update)
      const productUpdates = [];
      const itemsWithProducts = payload.items.map((it) => {
        let product = null;
        if (it.product_id) {
          product = productsList.find((p) => p.id === it.product_id) || null;
        }
        if (!product) {
          const name = String(it.product_name || '').trim().toLowerCase();
          product = productsList.find((p) => String(p.name || '').trim().toLowerCase() === name) || null;
        }
        if (product) {
          it.product_id = product.id;
          const needsUpdate =
            Number(product.price || 0) !== Number(it.mrp || 0) ||
            String(product.uom || '').toLowerCase() !== String(it.unit || '').toLowerCase();
          if (needsUpdate) {
            productUpdates.push(productsApi.update(product.id, {
              name: product.name,
              price: Number(it.mrp || 0),
              mrp: Number(it.mrp || 0),
              uom: it.unit || 'pcs',
              category: product.category || 'Groceries'
            }));
          }
          return it;
        }
        productUpdates.push(productsApi.create({
          name: it.product_name,
          price: Number(it.mrp || 0),
          mrp: Number(it.mrp || 0),
          uom: it.unit || 'pcs',
          category: 'Groceries',
          stock: 0
        }).then((createdProduct) => {
          if (createdProduct?.id) {
            it.product_id = createdProduct.id;
            setProductsList((prev) => [...prev, createdProduct]);
          }
          return it;
        }));
        return it;
      });

      if (productUpdates.length) {
        await Promise.all(productUpdates);
      }

      payload.customer_id = resolvedCustomerId;
      payload.items = itemsWithProducts;

      const result = await billingApi.createBill(payload);
      if (payload.customer_id && creditAmount > 0) {
        await creditApi.addTransaction(payload.customer_id, {
          type: 'given',
          amount: Number(creditAmount.toFixed(2)),
          description: 'Bill credit (payable - paid)',
          reference: result?.bill_number || null
        });
      }
      const shareText = buildShareText({
        bill_number: result?.bill_number,
        created_at: new Date().toISOString(),
        customer_name: payload.customer_name,
        customer_phone: payload.customer_phone,
        customer_email: payload.customer_email,
        customer_address: payload.customer_address,
        items: payload.items,
        total_amount: payload.total_amount,
        paid_amount: payload.paid_amount,
        credit_amount: payload.credit_amount,
        payment_status: payload.payment_status
      });
      setLastShareText(shareText);
      setLastShareNumber(result?.bill_number || '');
      alert('✓ Bill created successfully!');
      setCustomer({ name: '', email: '', phone: '', address: '' });
      setItems([createEmptyItem()]);
      setPaidAmount(0);
    } catch (err) {
      console.error('Error creating bill:', err);
      alert(`Failed to create bill: ${err.message || 'Unknown error'}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  const buildShareText = (bill) => {
    const items = Array.isArray(bill.items) ? bill.items : [];
    const lines = [
      `BILL #${bill.bill_number || ''}`,
      `Date: ${new Date(bill.created_at || Date.now()).toLocaleString()}`,
      `Customer: ${bill.customer_name || ''}`,
      bill.customer_phone ? `Phone: ${bill.customer_phone}` : null,
      bill.customer_email ? `Email: ${bill.customer_email}` : null,
      bill.customer_address ? `Address: ${bill.customer_address}` : null,
      '',
      'Items:'
    ];
    if (items.length === 0) {
      lines.push('- None');
    } else {
      items.forEach((it) => {
        const name = it.product_name || it.name || 'Item';
        const qty = Number(it.qty || it.quantity || 0);
        const unit = it.unit || '';
        const amount = Number(it.amount || 0);
        lines.push(`- ${name} ${qty}${unit ? ' ' + unit : ''} : Rs ${amount}`);
      });
    }
    lines.push('');
    lines.push(`Total: Rs ${Number(bill.total_amount || 0)}`);
    lines.push(`Paid: Rs ${Number(bill.paid_amount || 0)}`);
    lines.push(`Credit: Rs ${Number(bill.credit_amount || 0)}`);
    lines.push(`Status: ${bill.payment_status || ''}`);
    return lines.filter(Boolean).join('\n');
  };

  const handleCopyShare = async () => {
    if (!lastShareText) return;
    try {
      await navigator.clipboard.writeText(lastShareText);
      alert('Bill text copied.');
    } catch (err) {
      alert('Failed to copy bill text.');
    }
  };

  return (
    <div className="billing-content">
      <h1>Billing Invoice</h1>

      {error && (
        <div className="error-message" role="alert">
          {error}
          <button onClick={refreshData} className="retry-btn">Retry</button>
        </div>
      )}

      {loading && <div className="loading-indicator">Loading...</div>}

      {!loading && !error && (
        <button onClick={refreshData} className="refresh-btn" aria-label="Refresh customer and product data">
          Refresh Data
        </button>
      )}

      <div className="form-section">
        {/* Customer Name Field */}
        <div className="form-row">
          <label className="form-label" htmlFor="customerName">
            Customer Name *
          </label>
          <div className="input-wrapper">
            <input
              id="customerName"
              list="customer-list"
              className={`form-input ${getFieldError(customerValidation, 'name') ? 'input-error' : ''}`}
              value={customer.name}
              onChange={handleCustomerChange}
              placeholder="Type or select name..."
              aria-label="Customer name"
              aria-autocomplete="list"
              autoComplete="name"
              required
            />
            {getFieldError(customerValidation, 'name') && (
              <div className="error-icon" title={getFieldError(customerValidation, 'name')}>
                ⚠️
              </div>
            )}
            <datalist id="customer-list">
              {customersList.map((c) => (
                <option key={c.id} value={c.name} />
              ))}
            </datalist>
          </div>
        </div>

        {/* Phone Field */}
        <div className="form-row">
          <label className="form-label" htmlFor="customerPhone">Phone *</label>
          <div className="input-wrapper">
            <input
              id="customerPhone"
              type="tel"
              className={`form-input ${getFieldError(customerValidation, 'phone') ? 'input-error' : ''}`}
              value={customer.phone}
              onChange={(e) => setCustomer((prev) => ({ ...prev, phone: e.target.value }))}
              aria-label="Customer phone"
              placeholder="10-digit phone number"
              maxLength="10"
              autoComplete="tel"
            />
            {getFieldError(customerValidation, 'phone') && (
              <div className="error-icon" title={getFieldError(customerValidation, 'phone')}>
                ⚠️
              </div>
            )}
          </div>
        </div>

        {/* Email Field */}
        <div>
          <label className="form-label" htmlFor="customerEmail">Email</label>
          <div className="input-wrapper">
            <input
              id="customerEmail"
              type="email"
              className={`form-input ${getFieldError(customerValidation, 'email') ? 'input-error' : ''}`}
              value={customer.email}
              onChange={(e) => setCustomer((prev) => ({ ...prev, email: e.target.value }))}
              aria-label="Customer email"
              placeholder="email@example.com"
              autoComplete="email"
            />
            {getFieldError(customerValidation, 'email') && (
              <div className="error-icon" title={getFieldError(customerValidation, 'email')}>
                ⚠️
              </div>
            )}
          </div>
        </div>

        {/* Address Field */}
        <div>
          <label className="form-label" htmlFor="customerAddress">
            Address {customerValidation.warnings.length > 0 ? '⚠️' : ''}
          </label>
          <div className="input-wrapper">
            <input
              id="customerAddress"
              type="text"
              className={`form-input ${customerValidation.warnings.length > 0 ? 'input-warning' : ''}`}
              value={customer.address}
              onChange={(e) => setCustomer((prev) => ({ ...prev, address: e.target.value }))}
              aria-label="Customer address"
              placeholder="Full address"
              autoComplete="street-address"
            />
            {customerValidation.warnings.length > 0 && (
              <div className="error-icon warning" title={customerValidation.warnings[0]}>
                ⓘ
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="table-container">
        <table className="billing-table">
          <thead>
            <tr>
              <th>Product Name</th>
              <th className="w-24">Price</th>
              <th className="w-20">Qty</th>
              <th className="w-24">Unit</th>
              <th className="w-28">Disc</th>
              <th className="w-32">Amount</th>
              <th className="w-12"></th>
            </tr>
          </thead>
          <tbody>
            {items.map((item, index) => (
              <tr key={item.id}>
                <td data-label="Product Name">
                  <input
                    list="product-list"
                    value={item.name}
                    onChange={(e) => handleProductChange(index, 'name', e.target.value)}
                    aria-label="Product name"
                    placeholder="Type or select product..."
                    autoComplete="off"
                  />
                  <datalist id="product-list">
                    {productsList.map((p) => (
                      <option key={p.id} value={p.name} />
                    ))}
                  </datalist>
                </td>
                <td data-label="Price">
                  <input
                    type="number"
                    value={item.price}
                    onChange={(e) => handleProductChange(index, 'price', e.target.value)}
                    aria-label="Price per unit"
                    min="0"
                    step="0.01"
                  />
                </td>
                <td data-label="Quantity">
                  <input
                    type="number"
                    value={item.qty}
                    onChange={(e) => handleProductChange(index, 'qty', e.target.value)}
                    aria-label="Quantity"
                    min="1"
                  />
                </td>
                <td data-label="Unit">
                  <input
                    type="text"
                    value={item.unit}
                    onChange={(e) => handleProductChange(index, 'unit', e.target.value)}
                    aria-label="Unit of measurement"
                    placeholder="pcs, kg, etc."
                  />
                </td>
                <td data-label="Discount">
                  <div className="discount-field">
                    <input
                      type="number"
                      value={item.disc}
                      onChange={(e) => handleProductChange(index, 'disc', e.target.value)}
                      aria-label="Discount value"
                      min="0"
                      step={item.discType === 'percentage' ? '1' : '0.01'}
                      className="disc-input"
                    />
                    <select
                      value={item.discType}
                      onChange={(e) => handleProductChange(index, 'discType', e.target.value)}
                      aria-label="Discount type"
                      className="disc-type-select"
                    >
                      <option value="fixed">Rs</option>
                      <option value="percentage">%</option>
                    </select>
                  </div>
                </td>
                <td className="amount-cell" data-label="Amount">{formatCurrency(item.amount)}</td>
                <td className="text-center" data-label="Action">
                  <button
                    onClick={() => removeItem(index)}
                    disabled={items.length === 1}
                    className="delete-btn"
                    aria-label="Remove item"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      <div className="actions">
        <button onClick={addItem} className="add-btn" aria-label="Add new product">
          <Plus size={18} /> Add Product
        </button>
        <div className="total-section">
          <p>Total Payable:</p>
          <p>{formatCurrency(totalBill)}</p>
        </div>
      </div>

      <div className="form-section">
        <div className="form-row">
          <label className="form-label" htmlFor="paidAmount">Paid Amount</label>
          <input
            id="paidAmount"
            type="number"
            min="0"
            step="0.01"
            className="form-input"
            value={paidAmount}
            onChange={(e) => setPaidAmount(e.target.value)}
            placeholder="0.00"
          />
        </div>
        <div className="form-row">
          <label className="form-label">Credit (Payable - Paid)</label>
          <div className="form-input" aria-live="polite">
            {formatCurrency(creditAmount)}
          </div>
        </div>
      </div>

      <div className="billing-form-controls">
        <button className="reset" onClick={() => {
          setCustomer({ name: '', email: '', phone: '', address: '' });
          setItems([createEmptyItem()]);
          setPaidAmount(0);
        }}>
          Clear
        </button>
        <button 
          className="submit" 
          onClick={handleCreateBill} 
          disabled={isSubmitting || !customerValidation.isValid || !items.some((it) => it.name && it.amount > 0)}
          title={
            isSubmitting ? 'Creating bill...' :
            !customerValidation.isValid ? 'Fix customer information errors before creating bill' :
            !items.some((it) => it.name && it.amount > 0) ? 'Add at least one item to the bill' :
            'Create bill'
          }
        >
          ✓ Create Bill
        </button>
      </div>

      {lastShareText && (
        <div className="share-box">
          <div className="share-header">
            <strong>Share Bill {lastShareNumber ? `#${lastShareNumber}` : ''}</strong>
          </div>
          <textarea className="share-text" readOnly value={lastShareText} />
          <div className="share-actions">
            <button className="share-btn" onClick={handleCopyShare}>Copy</button>
            <a
              className="share-btn whatsapp"
              href={`https://wa.me/?text=${encodeURIComponent(lastShareText)}`}
              target="_blank"
              rel="noreferrer"
            >
              WhatsApp
            </a>
          </div>
        </div>
      )}
    </div>
  );
};

export default BillingSystem;
